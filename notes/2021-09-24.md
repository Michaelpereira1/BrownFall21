---
jupytext:
  text_representation:
    extension: .md
    format_name: myst
    format_version: 0.13
    jupytext_version: 1.10.3
kernelspec:
  display_name: Python 3
  language: python
  name: python3
---

# Exploratory Data Analysis


```{code-cell} ipython3
import pandas as pd
import seaborn as sns
```


```{code-cell} ipython3
arabica_data_url = 'https://raw.githubusercontent.com/jldbc/coffee-quality-database/master/data/arabica_data_cleaned.csv'

coffee_df = pd.read_csv(arabica_data_url)
```

Which of the following scores is distributed most similarly to Sweetness?


```{code-cell} ipython3
scores_of_interest = ['Flavor','Balance','Aroma','Body',
                      'Uniformity','Aftertaste','Sweetness']
```

First step is to subset the data:
```{code-cell} ipython3
coffee_df[scores_of_interest].head(2)
```

Then we produce a kde plot  
```{code-cell} ipython3
coffee_df[scores_of_interest].plot(kind='kde')
```

We could also do it with seaborn
```{code-cell} ipython3
sns.displot(data=coffee_df[scores_of_interest],kind='kde')
```

If we forget the parameter `kind`, we get its default value,
which is histogram
````{margin}
```{note}
If you show this excerpt, you'll see how I was able to select only a subset of the docstring to display in the notebook, programmatically. You're not required to know how to do it, but if you're curious, you can see.
```
````
```{code-cell} ipython3
:tags: ["hide-input"]
print('\n'.join(sns.displot.__doc__.split('\n')[5:10]))
```

```{code-cell} ipython3
sns.displot(data=coffee_df[scores_of_interest])
```

## Summarizing with two variables

So, we can summarize data now, but the summaries we have done so far have treated each variable one at a time.  The most interesting patterns are in often in how multiple variables interact. We'll do some modeling that looks at multivariate functions of data in a few weeks, but for now, we do a little more with summary statistics.

On Monday, we saw how to see how many reviews there were per country, using `value_counts()` on the `Country.of.Origin` column.

```{code-cell} ipython3
coffee_df['Country.of.Origin'].value_counts().head(2)
```

The data also has `Number.of.Bags` however.  How can we check which has the most bags?

We can do this with groupby.

```{code-cell} ipython3
coffee_df.groupby('Country.of.Origin')['Number.of.Bags'].sum()
```


What just happened?
![split-apply-combine](https://jakevdp.github.io/PythonDataScienceHandbook/figures/03.08-split-apply-combine.png)


We can view this by saving the groupby object as a variable and exploring it.


```{code-cell} ipython3
country_grouped = coffee_df.groupby('Country.of.Origin')

country_grouped
```

Trying to look at it without applying additional functions, just tells us the type.  But, it's iterable, so we can loop over.


```{code-cell} ipython3
for country,df in country_grouped:
    print(type(country), type(df))
```

````{margin}
```{note}
I used this feature to build the separate view of the communication channels on this website.  You can view that source using the github icon on that page.
```
````

We could manually compute things using the data structure, if needed, though using pandas functionality will usually do what we want. For example:

````{margin}
```{note}
I tried putting this dictionary into the dataframe for display purposes using the regular constructor and got an error, so I googled about making one from a dictionary to get the docs, which is how I learned about the [`from_dict`](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.from_dict.html) method and its `orient` parameter which solved my problems.
```
````

```{code-cell} ipython3
bag_total_dict = {}

for country,df in country_grouped:
    tot_bags =  df['Number.of.Bags'].sum()
    bag_total_dict[country] = tot_bags

pd.DataFrame.from_dict(bag_total_dict, orient='index',
                           columns = ['Number.of.Bags.Sum'])
```

is the same as what we did before

```{admonition} Question from class
How can we sort it?
```

First, we'll make it a variable to keep the code legible, then we'll use `sort_values()`

```{code-cell} ipython3
bag_total_df = coffee_df.groupby('Country.of.Origin')['Number.of.Bags'].sum()
bag_total_df.sort_values()
```

Which, by default uses ascending order, the method has an `ascending` parameter and its default value is `True`, so we can switch it to `False` to get descending

```{code-cell} ipython3
bag_total_df.sort_values(ascending=False,)
```

## Customizing Data Summaries

We've looked at an overall summary with `describe` on all the variables,  describe on one variable, individual statistics on all variables, and individual statistics on one variable.  We can also build  summaries of multiple varialbes with a custom subset of summary statistics, with `aggregate` or using its alias `agg`

```{code-cell} ipython3
country_grouped.agg({'Number.of.Bags':'sum',
                     'Balance':['mean','count'],})
```

We could also string this together
```{code-cell} ipython3
coffee_df.groupby('Country.of.Origin').agg({'Number.of.Bags':'sum','Balance':['mean','count'],})
```

## Questions after class

```{admonition} Ram Token Opportunity
add a question with a pull request; earn 1-2 ram tokens for submitting a question with the answer (with sources)
```

## More Practice

- Make a table thats total number of bags and mean and count of scored for each of the variables in the `scores_of_interest` list.
- Make a bar chart of the mean score for each variable `scores_of_interest` grouped by country. 
