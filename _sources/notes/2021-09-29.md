---
jupytext:
  text_representation:
    extension: .md
    format_name: myst
    format_version: 0.13
    jupytext_version: 1.10.3
kernelspec:
  display_name: Python 3
  language: python
  name: python3
---

# More Reshaping

```{code-cell} ipython3
import pandas as pd
import seaborn as sns

# make plots look nicer and increase font size
sns.set_theme(font_scale=2)
arabica_data_url = 'https://raw.githubusercontent.com/jldbc/coffee-quality-database/master/data/arabica_data_cleaned.csv'

coffee_df = pd.read_csv(arabica_data_url)

# compute ___ per ___
bag_total_df = coffee_df.groupby('Country.of.Origin')['Number.of.Bags'].sum()

# subset the summary Series for countries with over 15000 total and store as a list
high_prod_countries = list(bag_total_df[bag_total_df>15000].index)

# a lambda function that checks if a string c is one of the
#  countries in high_prod_countries
high_prod = lambda c: c in high_prod_countries

# add a column that indicates that the country is a high producer
coffee_df['high_production'] = coffee_df['Country.of.Origin'].apply(high_prod)



# filter based on production level threshold
high_prod_coffee_df = coffee_df[coffee_df['high_production']]
```

```{code-cell} ipython3
coffee_df.shape, high_prod_coffee_df.shape
```


replace the FIXMEs in the excerpt tbelo to
reshape the data to have a value column with the value of the score
and a Score column that indicates which score is in that
row. Retaint he country and color for each score, so that they can be used
as grouping variables

```{code-cell} ipython3
# replace the FIXMEs
scores_of_interest = ['Balance','Aroma','Body','Aftertaste']
attrs_of_interest = ['Country.of.Origin','Color']
high_prod_coffee_df_melted = high_prod_coffee_df.melt(
    id_vars = attrs_of_interest,
    value_vars = scores_of_interest,
    var_name = 'Score')
```

What happened?
```{code-cell} ipython3
high_prod_coffee_df_melted.shape
```


```{code-cell} ipython3
high_prod_coffee_df_melted.head()
```

```{code-cell} ipython3
high_prod_coffee_df_melted.sample(5)
```

```{code-cell} ipython3
sns.displot(data= high_prod_coffee_df_melted,
           x='value',hue='Country.of.Origin',
           col = 'Score', col_wrap=2, kind='kde',aspect =1.5)
```

## unpacking Jsons

```{code-cell} ipython3
rhodyprog4ds_gh_events_url = 'https://api.github.com/orgs/rhodyprog4ds/events'
prof_gh_events_url = 'https://api.github.com/users/brownsarahm/events'
```

```{code-cell} ipython3
course_gh_df = pd.read_json(rhodyprog4ds_gh_events_url)
course_gh_df.head()
```
We want to transform each one of those from a dictionary like thing into a
row in a data frame.

```{code-cell} ipython3
type(course_gh_df['actor'])
```

Recall, that base python types can be used as function, to cast an object from
type to another.
```{code-cell} ipython3
5
```

```{code-cell} ipython3
type(5)
```

```{code-cell} ipython3
str(5)
```

How can we unpack one column?
what method used above on a a Series (single column) allowed us to call the same
fucntion on every value in the column?
```{code-cell} ipython3
course_gh_df['actor'].head(2)
```

```{code-cell} ipython3
course_gh_df['actor'][0]
```

```{code-cell} ipython3
course_gh_df['actor'].apply(pd.Series)
```

HOw can we do this for all of the columns and put them back together after?

```{code-cell} ipython3
js_cols = ['actor','repo','payload','org']
```


`pd.concat` takes a list of dataframes and puts the together in one DataFrame.

to illustrate, it's nice to make a small small dataFrame.

```{code-cell} ipython3
pd.concat([course_gh_df[cur_col].apply(pd.Series) for cur_col in js_cols],
         axis=1)
```

```{code-cell} ipython3
pd.concat([course_gh_df[cur_col].apply(pd.Series) for cur_col in js_cols],
         axis=1).shape
```

```{code-cell} ipython3
pd.concat([course_gh_df[cur_col].apply(pd.Series) for cur_col in js_cols],
         axis=0).shape
```

we might want to rename the new columns so that they have the original column
name prepended to the new name.

pandas has a rename method for this.

and this is another job for lambdas.
```{code-cell} ipython3
pd.concat([course_gh_df[cur_col].apply(pd.Series).rename(columns = lambda c: cur_col + '_' +c)
           for cur_col in js_cols],
         axis=1)
```

```{code-cell} ipython3
pd.concat([course_gh_df[cur_col].apply(pd.Series).rename(columns = lambda c: cur_col + '_' +c)
           for cur_col in js_cols],
         axis=1).shape
```

How can we append the new columns to the old ones?
```{code-cell} ipython3
pd.concat([course_gh_df[[col for col in
          course_gh_df.columns if not(col in js_cols)]
         ]]+[course_gh_df[col].apply(pd.Series,).rename(
  columns= lambda i_col: col + '_' + i_col )
      for col in js_cols],axis=1)
```

```{code-cell} ipython3

```
